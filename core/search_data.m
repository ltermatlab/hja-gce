function [paths,filenames,varnames,accessions,titles,daterange] = search_data(qry,index,pn)
%Identifies GCE Data Structures in one or more directories matching specified search criteria
%based on information stored in a search index structure (see 'search_index'). Note that
%all metadata field searches are based on partial string matches except for 'Variables' and
%'Sites', which are based on matching the beginning portion of each string. Prefacing any search
%string with '-' excludes records that match the string.
%
%syntax: [paths,filenames,varnames,accessions,titles,daterange] = search_data(qry,index,pn)
%
%inputs:
%  qry = query statement string containing any or all of the following field/value pairs delimited by semi-colons:
%     [various text fields] = various metadata text fields definied in 'search_data.mat',
%       e.g. Title, Abstract, Methods, Study, etc. (partial string search)
%     AllText = all metadata text (Title+Abstract+CoreArea+Methods+Study; partial string search)
%     Author = author name text (partial string search)
%     DateStart = minimum start date (date/time string, e.g. 01-Jan-2001 or 1/1/2001)
%     DateEnd = maximum study end date (date/time string)
%     DateContains = intermediate study date (date/time string)
%     Keywords = comma-delimited list of keywords (partial string search)
%     Taxa = comma-delimited list of taxa (partial string search)
%     Columns = comma-delimited list of column names (exact string search)
%     Units = comma-delimited list of column units (exact string search)
%     Descriptions = comma-delimited list of column description terms (partial string search)
%     VariableTypes = comma-delimited list of column variable types (exact string search)
%     Columns+Units = comma-delimited list of column names with  corresponding units separated
%       by a space (e.g. Salinity PSU)
%     Sites = comma-delimited list of site codes (exact string search)
%     BoundingBox = text array of geographic bounding box limits ('[wlon,elon,slat,nlat]',
%       containing values in decimal degrees or NaN for +/- infinity bounds)
%     BoundingBoxMode = [inside/intersect]  (bounding box match option, default = inside)
%     MatchType = [all/any]   (query term match option, default = 'all')
%     MatchCase = [TRUE/FALSE]  (text case match option, default = 'FALSE')
%  index = search index generated by 'search_index' to use, or the name of a file
%     containing a valid search index (note: index file will be created if it does not exist)
%  pn = pathname of index file (default = pwd)
%
%outputs:
%  paths = list of paths for matched data sets
%  filenames = list of filenames for matched data sets
%  varnames = list of variable names for matched data sets
%  accessions = list of accession numbers for matched data sets
%  titles = titles for matched data sets
%  daterange = date range for each matched data set
%
%
%(c)2002-2011 Wade M. Sheldon and the Georgia Coastal Ecosystems LTER Project
%
%This file is part of the GCE Data Toolbox for MATLAB(r) software library.
%
%The GCE Data Toolbox is free software: you can redistribute it and/or modify it under the terms
%of the GNU General Public License as published by the Free Software Foundation, either version 3
%of the License, or (at your option) any later version.
%
%The GCE Data Toolbox is distributed in the hope that it will be useful, but WITHOUT ANY
%WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
%PURPOSE. See the GNU General Public License for more details.
%
%You should have received a copy of the GNU General Public License along with The GCE Data Toolbox
%as 'license.txt'. If not, see <http://www.gnu.org/licenses/>.
%
%contact:
%  Wade Sheldon
%  GCE-LTER Project
%  Department of Marine Sciences
%  University of Georgia
%  Athens, GA 30602-3636
%  sheldon@uga.edu
%
%last modified: 09-Oct-2011

%init outputs
paths = [];
filenames = [];
varnames = [];
titles = [];
accessions = [];
daterange = [];

if nargin >= 2

   if length(qry) > 10

      %init outputs
      indexfile = '';
      curpath = pwd;

      if exist('pn','var') ~= 1
         pn = curpath;
      end

      if ischar(index)
         indexfile = index;
         index = [];
      end

      if ~isempty(indexfile)
         if exist([pn,filesep,indexfile],'file') == 2
            vars = load([pn,filesep,indexfile],'-mat');
            if isfield(vars,'index')
               index = vars.index;
            end
         end
      end

      %split query terms based on semicolons
      ar = splitstr(qry,';');

      %init query term variables, setting default values if terms omitted
      match_case = 0;  %default to non case sensitive text searches
      exclusive = 1;   %default to exlusive matches (all terms)
      metasearchfields = [];
      date_start = [];
      date_end = [];
      date_contains = [];
      bbox = [];
      bboxmode = 'inside';  %default to exclusive bounding box searches (datasets within bounds)

      %init arrays of metadata text fields, list fields
      s_metafields = [];
      s_listfields = [];

      %try to load field lists from config file
      if exist('search_data.mat','file') == 2
         try
            v = load('search_data.mat');
         catch
            v = struct('null','');
         end
         if isfield(v,'metafields') && isfield(v,'listfields')
            s_metafields = v.metafields;
            s_listfields = v.listfields;
         end
      end

      %use defaults if config file missing/invalid
      if isempty(s_metafields)
         %array of metadata text fields to search: field, description, search_type, index_type, metadata_sections
         metafields = {'title','Title Text','contains','minimal',{'Dataset','Title'}; ...
               'abstract','Abstract Text','contains','full',{'Dataset','Abstract'}; ...
               'methods','Methods Text','contains','full',{'Study','Methods'}; ...
               'study','Study Text','contains','full',{'Study','Description';'Study','Sampling'}; ...
               'corearea','Core Area','contains','full',{'Dataset','LTERCore';'Dataset','Themes'}; ...
               'accession','Accession','starts','minimal',{'Dataset','Accession'}};
      else
         metafields = [lower({s_metafields.Field}'),{s_metafields.Label}',{s_metafields.SearchType}', ...
               {s_metafields.IndexType}',{s_metafields.MetaFields}'];
      end
      if isempty(s_listfields)
         listfields = {'keywords','Keywords','starts',[]; ...
               'taxa','Taxa','contains',[]; ...
               'columns','Columns','exact',[]; ...
               'units','Units','exact',[]; ...
               'descriptions','Column Descriptions','contains',[]; ...
               'variabletypes','Variable Types','exact',[]; ...
               'columns+units','Columns + Units','exact',[]; ...
               'sites','Sites','exact',[]};
      else
         listfields = [lower({s_listfields.Field}'),{s_listfields.Label}', ...
               {s_listfields.SearchType}',repmat({[]},length(s_listfields),1)];
      end

      %parse query terms
      for n = 1:length(ar)

         vals = splitstr(ar{n},'=');  %split field, value on '='

         if length(vals) == 2

            %get search field, search item from array
            fld = vals{1};
            opt = vals{2};

            %evaluate by field type
            switch fld
               case 'MatchType'
                  if strcmp(opt,'all')
                     exclusive = 1;
                  else
                     exclusive = 0;
                  end
               case 'MatchCase'
                  if strcmp(opt,'TRUE')
                     match_case = 1;
                  else
                     match_case = 0;
                  end
               case 'DateStart'
                  date_start = datenum(opt);
               case 'DateEnd'
                  date_end = datenum(opt);
               case 'DateContains'
                  date_contains = datenum(opt);
               case 'BoundingBox'
                  if ~strcmp(opt(1),'['); opt = ['[',opt]; end
                  if ~strcmp(opt(end),']'); opt = [bbox,']']; end
                  bbox = str2num(opt);
               case 'BoundingBoxMode'
                  bboxmode = opt;
               otherwise  %check for list or metadata field
                  Ilistfield = find(strcmpi(listfields(:,1),fld));  %check for list field
                  if ~isempty(Ilistfield)
                     listfields{Ilistfield,4} = splitstr(opt,',');  %split list search values into array
                  else  %assume metadata field
                     Imetafield = find(strcmpi(metafields(:,1),fld));  %check for standard metadata field
                     if ~isempty(Ilistfield)
                        metasearchfields = [metasearchfields ; ...
                              metafields(Imetafield(1),1),{opt},metafields(Imetafield(1),3)];  %store metadata field, criteria, search type
                     else  %use default search type
                        metasearchfields = [metasearchfields ; {lower(fld),opt,'contains'}];   %use default 'contains' type search
                     end
                  end
            end
         end
      end

      %build search index if necessary
      if isempty(index)
         index = search_index(pn,[],'rebuild',1,indexfile);
      end

      %check for valid index structure before proceeding
      if ~isempty(index)

         %test for no criteria condition
         if ~isempty(metasearchfields) || ~isempty(date_start) || ~isempty(date_end) || ~isempty(date_contains) || ...
               ~isempty(bbox) || ~isempty(find(~cellfun('isempty',listfields(:,4))))

            %look up index length
            numrecs = length(index);

            %init master search result indices
            Imeta = zeros(numrecs,1);  %cumulative index for metadata field searches
            Ilistmatches = Imeta;  %cumulative index for list-based searches
            Idatestart = Imeta;
            Idateend = Imeta;
            Idatecontains = Imeta;
            Ibbox = Imeta;

            %init match check arrays for optimizing search efficiency
            Imatchcheck = zeros(numrecs,1);
            Iresid = [1:numrecs]';

            %init criteria counter for all-match check
            numcrit = 0;

            %perform start date search
            if ~isempty(date_start)
               numcrit = numcrit + 1;  %inc crit counter
               dt = [index.date_start]';  %get start dates
               Ivalid = find(~isnan(dt)); %get index of non-NaN values
               if ~isempty(Ivalid)
                  Imatch = find(dt(Ivalid) >= date_start);
                  if ~isempty(Imatch)
                     Itmp = Ivalid(Imatch);
                     Idatestart(Itmp) = 1;
                     Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;  %update residual index
                     if exclusive == 0
                        Iresid = find(Imatchcheck == 0);  %get index of non-matches for residual searches
                     else
                        Iresid = find(Imatchcheck == numcrit);  %get index of matches for residual searches
                     end
                  end
               end
            end

            %perform end date search
            if ~isempty(date_end) && ~isempty(Iresid)
               numcrit = numcrit + 1;
               dt = [index(Iresid).date_end]';
               Ivalid = find(~isnan(dt));
               if ~isempty(Ivalid)
                  Imatch = find(dt(Ivalid) <= date_end);
                  if ~isempty(Imatch)
                     Itmp = Iresid(Ivalid(Imatch));
                     Idateend(Itmp) = 1;
                     Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;  %update residual index
                     if exclusive == 0
                        Iresid = find(Imatchcheck == 0);
                     else
                        Iresid = find(Imatchcheck == numcrit);
                     end
                  end
               end
            end

            %perform intermediate date search
             if ~isempty(date_contains) && ~isempty(Iresid)
               numcrit = numcrit + 1;
               dt1 = [index(Iresid).date_start]';
               dt2 = [index(Iresid).date_end]';
               Ivalid = find(~isnan(dt1) & ~isnan(dt2));
               if ~isempty(Ivalid)
                  Imatch = find((dt1(Ivalid) <= date_contains) & (dt2(Ivalid) >= date_contains));
                  if ~isempty(Imatch)
                     Itmp = Iresid(Ivalid(Imatch));
                     Idatecontains(Itmp) = 1;
                     Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;  %update residual index
                     if exclusive == 0
                        Iresid = find(Imatchcheck == 0);
                     else
                        Iresid = find(Imatchcheck == numcrit);
                     end
                  end
               end
            end

            %perform bounding box search
            if ~isempty(bbox) && ~isempty(Iresid)

               numcrit = numcrit + 1;

               if strcmp(bboxmode,'inside')  %match data sets entirely within bounds

                  %supply infinite limits for omitted bounds
                  if isnan(bbox(1)); bbox(1) = -inf; end
                  if isnan(bbox(2)); bbox(2) = inf; end
                  if isnan(bbox(3)); bbox(3) = -inf; end
                  if isnan(bbox(4)); bbox(4) = inf; end

                  %get arrays of dataset bounds
                  wlon = [index(Iresid).wboundlon]';
                  elon = [index(Iresid).eboundlon]';
                  slat = [index(Iresid).sboundlat]';
                  nlat = [index(Iresid).nboundlat]';

                  %get index of all non-nan bounds
                  Ivalid = find([~isnan(wlon) & ~isnan(elon) & ~isnan(slat) & ~isnan(nlat)]);

                  %check for valid coordinates
                  if ~isempty(Ivalid)

                     %apply non-nan index to arrays
                     wlon = wlon(Ivalid);
                     elon = elon(Ivalid);
                     slat = slat(Ivalid);
                     nlat = nlat(Ivalid);

                     %search for bounds within limits
                     Imatch = find(wlon >= bbox(1) & elon <= bbox(2) & slat >= bbox(3) & nlat <= bbox(4));

                     %check for matches, update indices
                     if ~isempty(Imatch)
                        Ibbox(Iresid(Ivalid(Imatch))) = 1;
                        Itmp = find(Ibbox);
                        Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;
                        if exclusive == 0
                           Iresid = find(Imatchcheck == 0);
                        else
                           Iresid = find(Imatchcheck == numcrit);
                        end
                     end

                  end

               else  %translate bbox to site list, search for data sets with any sites in list (regardless of match type)

                  sitelist = bbox2sites(bbox,'polygon');  %call external function to look up site polygons overlapping with bbox

                  %perform site list match search for indexed data sets
                  if ~isempty(sitelist)
                     for n = 1:length(Iresid)
                        ar = index(Iresid(n)).sites;
                        if ~isempty(ar)
                           for m = 1:length(sitelist)
                              Itmp = find(sub_searchstrings(ar,sitelist{m},match_case,'starts'));
                              if ~isempty(Itmp)
                                 Ibbox(Iresid(n)) = 1;
                                 break  %found a site - kick out of site comparison loop
                              end
                           end
                        end
                     end
                     Itmp = find(Ibbox);
                     Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;
                     if exclusive == 0
                        Iresid = find(Imatchcheck == 0);
                     else
                        Iresid = find(Imatchcheck == numcrit);
                     end
                  end

               end
            end

            %perform generic metadata field searches
            if ~isempty(metasearchfields) && ~isempty(Iresid)
               numcrit = numcrit + 1;
               Iallmeta = zeros(numrecs,1);
               for m = 1:size(metasearchfields,1)
                  metasearchfield = metasearchfields{m,1};
                  metastr = metasearchfields{m,2};
                  searchtypestr = metasearchfields{m,3};
                  if ~strcmp(metasearchfield,'anytext')
                     if ~isempty(metastr) && isfield(index,metasearchfield)  %check for valid search item and existance of field
                        %populate lookup list
                        str = {index(Iresid).(metasearchfield)}';
                        Iempty = find(cellfun('isempty',str));
                        if ~isempty(Iempty)
                           str(Iempty) = {''};  %replace empty cells with empty strings to avoid string comparison errors
                        end
                        %add search results to cumulative index
                        Itemp = sub_searchstrings(str,metastr,match_case,searchtypestr);
                        Iallmeta(Iresid) = Iallmeta(Iresid) + Itemp;
                     end
                  else  %all metadata search - concat fields
                     allstr = [];
                     for n = 1:size(metafields,1)
                        fld = lower(metafields{n,1});
                        if isfield(index,fld)
                           allstr = [allstr,{index(Iresid).(fld)}'];
                        end
                     end
                     str = concatcellcols(allstr,' ');
                     Itemp = sub_searchstrings(str,metastr,match_case,searchtypestr);
                     Iallmeta(Iresid) = Iallmeta(Iresid) + Itemp;
                  end
               end
               if exclusive == 1  %set search value = 1 for records matching all fields
                  Imatch = find(Iallmeta == size(metasearchfields,1));
               else  %set search value = 1 for records matching any fields
                  Imatch = find(Iallmeta);
               end
               Imeta(Imatch) = 1;
               Itmp = find(Imeta);
               Imatchcheck(Itmp) = Imatchcheck(Itmp) + 1;
               if exclusive == 0
                  Iresid = find(Imatchcheck == 0);  %update pointer array
               else
                  Iresid = find(Imatchcheck == numcrit);
               end
            end

            %perform list-based searches (beginning string matches)
            Ilists = find(~cellfun('isempty',listfields(:,4)));
            numlists = length(Ilists);

            if numlists > 0 && ~isempty(Iresid)

               numcrit = numcrit + numlists;

               %loop through all list search items
               for listitem = 1:numlists

                  indexfld = listfields{Ilists(listitem),1};  %get index field from array
                  matchtype = listfields{Ilists(listitem),3};  %get match type from array
                  listvals = listfields{Ilists(listitem),4};  %get list vals from array
                  Iitems = zeros(numrecs,1);  %init overall variable match index

                  if ~isempty(strfind(indexfld,'+'))  %evaluate compound index field searches

                     ar_indexfld = splitstr(indexfld,'+');
                     num_valid = 0;  %validate field selections

                     for m = 1:length(ar_indexfld)
                        if isfield(index,ar_indexfld{m})
                           num_valid = num_valid + 1;
                        end
                     end

                     if num_valid == length(ar_indexfld)
                        for m = 1:length(listvals)  %loop through relevant list for each index record
                           for n = 1:length(Iresid)
                              ar = [];
                              for cnt = 1:length(ar_indexfld)
                                 tmp = index(Iresid(n)).(ar_indexfld{cnt});
                                 if isempty(ar) || size(ar,1)==size(tmp,1)
                                    ar = [ar,tmp];
                                 end
                              end
                              if ~isempty(ar)
                                 ar = concatcellcols(ar,' ');  %concatenate array columns
                                 str = listvals{m};
                                 if str(1) ~= '-';
                                    Itmp = find(sub_searchstrings(ar,str,match_case,matchtype));
                                    if ~isempty(Itmp)
                                       Iitems(Iresid(n)) = Iitems(Iresid(n)) + 1;  %increment overall match index
                                    end
                                 else
                                    Itmp = find(sub_searchstrings(ar,str(2:end),match_case,matchtype));
                                    if isempty(Itmp)
                                       Iitems(Iresid(n)) = Iitems(Iresid(n)) + 1;  %increment overall match index
                                    end
                                 end
                              end
                           end
                        end
                     end

                  elseif isfield(index,indexfld)  %check validity of simple list field
                     for m = 1:length(listvals)  %loop through relevant list for each index record
                        for n = 1:length(Iresid)
                           ar = index(Iresid(n)).(indexfld);
                           if ~isempty(ar)
                              str = listvals{m};
                              if str(1) ~= '-';
                                 Itmp = find(sub_searchstrings(ar,str,match_case,matchtype));
                                 if ~isempty(Itmp)
                                    Iitems(Iresid(n)) = Iitems(Iresid(n)) + 1;  %increment overall match index
                                 end
                              else
                                 Itmp = find(sub_searchstrings(ar,str(2:end),match_case,matchtype));
                                 if isempty(Itmp)
                                    Iitems(Iresid(n)) = Iitems(Iresid(n)) + 1;  %increment overall match index
                                 end
                              end
                           end
                        end
                     end
                  end

                  %for relevant match indices
                  if exclusive == 1 %set index value = 1 for records matching all list values, zero otherwise
                     Imatch = (Iitems == length(listvals));
                  else  %set index value = 1 for records matching any list values
                     Imatch = (Iitems >= 1);
                  end

                  Ilistmatches = Ilistmatches + Imatch;  %add to cumulative match index

               end

               %evaluate residual search records
               Itmp = find(Ilistmatches);
               Imatchcheck(Itmp) = Imatchcheck(Itmp) + numlists;
               if exclusive == 0
                  Iresid = find(Imatchcheck == 0);
               else
                  Iresid = find(Imatchcheck == numcrit);
               end

            end

            %form composite index
            I_all = Imeta + Ilistmatches + Idatestart + Idateend + Idatecontains + Ibbox;

            if exclusive == 0  %match any criteria
               I_all = find(I_all);
            else  %match all criteria
               I_all = find(I_all == numcrit);
            end

            %apply final match index to index fields
            if ~isempty(I_all)
               paths = {index(I_all).path}';
               filenames = {index(I_all).filename}';
               varnames = {index(I_all).varname}';
               if isfield(index,'accession')
                  accessions = {index(I_all).accession}';
               else
                  accessions = repmat({''},length(I_all),1);
               end
               if isfield(index,'title')
                  titles = {index(I_all).title}';
               else
                  titles = repmat({'no title'},length(I_all),1);
               end
               daterange = sub_daterange(index(I_all));
            end

         else  %match all files - no criteria specified
            paths = {index.path}';
            filenames = {index.filename}';
            varnames = {index.varname}';
            if isfield(index,'accession')
               accessions = {index.accession}';
            else
               accessions = repmat({''},length(index),1);
            end
            if isfield(index,'title')
               titles = {index.title}';
            else
               titles = repmat({'no title'},length(index),1);
            end
            daterange = sub_daterange(index);
         end

      else  %clear dummy index, return empty matrix
         index = [];
      end

   end

end


%subfunction definitions

%subfunction for formatting study period strings
function daterange = sub_daterange(index)

numrecs = length(index);
str1 = repmat({'??/??/??'},numrecs,1);
str2 = str1;

if mlversion >= 6
   dformat = 23;
else
   dformat = 2;
end

Ivalid = find(~isnan([index.date_start]'));
if ~isempty(Ivalid)
   dt1 = cellstr(datestr([index(Ivalid).date_start]',dformat));
   [str1(Ivalid)] = deal(dt1(:));
end

Ivalid = find(~isnan([index.date_end]'));
if ~isempty(Ivalid)
   dt2 = cellstr(datestr([index(Ivalid).date_end]',dformat));
   [str2(Ivalid)] = deal(dt2(:));
end

daterange = concatcellcols([repmat({'(period: '},numrecs,1),str1,repmat({' - '},numrecs,1),str2,repmat({')'},numrecs,1)]);

return


function Imatch = sub_searchstrings(ar,str,match_case,match_type)
%subfunction for searching for strings in a cell array
%
%input:
%  ar = cell array of strings to search
%  str = string token to find
%  match_case = match case option (0 = no, 1 = yes)
%  match_type = match type:
%    'contains' = match strings in ar that contain str (default)
%    'starts' = match strings in ar that begin with str
%    'exact' = match strings in ar that equal str
%
%output:
%  Imatch = index of elements in ar that match str

Imatch = [];

if exist('match_type','var') ~= 1
   match_type = 'contains';
end

if ~isempty(ar) && ~isempty(str)

   numrows = length(ar);
   Imatch = zeros(numrows,1);

   %convert all to lower case if not case-sensitive
   if match_case == 0
      str = lower(str);
      ar = lower(ar);
   end

   %check for negative search criteria
   if str(1) == '-'
      str = str(2:end);  %strip leading negative
      exclude = 1;  %set exclude flag
   else
      exclude = 0;
   end

   %perform search using relevant method
   switch match_type
      case 'starts'
         Imatch = strncmp(ar,str,length(str));
      case 'contains'
         str_pad = blanks(length(str));  %generate padding array
         for n = 1:numrows
            str_search = [ar{n},str_pad];  %pad search string to avoid reverse partial match
            if ~isempty(strfind(str_search,str))
               Imatch(n) = 1;
            end
         end
      case 'exact'
         Imatch = strcmp(ar,str);
   end

   if exclude == 1
      Imatch = ~Imatch;  %invert match results if exclude flag set
   end

end