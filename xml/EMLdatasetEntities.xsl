<?xml version="1.0"?>
<!-- 
This stylesheet takes an EML document as input and creates a MATLAB m-file function to return a list of 
all dataTable entities in simpleDelimited text format that contain download urls and attribute descriptors.

The m-file returns a cell array of names from eml/dataset/dataTable/entityName elements
that contain downloadable text files compatible with EMLdataset2mfile.xsl

Note that the output of the XSLT is a plain text file that must be saved as a file with a .m
extension to be called from MATLAB. The m-file also calls 'urlwrite' to download the data
objects, which requires MATLAB 6.5 (R13) or higher, and calls 'textscan.m' to parse the data,
which requires MATLAB 7 (R14) or higher. The XSLT must be rewritten to use the 'textread.m'
function or equivalent to parse files using MATLAB 6.5.

version 0.1 (18-Jun-2013)

Copyright 2013 Wade M. Sheldon and the Georgia Coastal Ecosystems LTER Program

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-->

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
   
   <!-- set options for text output, stripping extra whitespace globally -->
   <xsl:output method="text" indent="no"/>
   <xsl:strip-space elements="*"/>
   
   <!-- master template -->
   <xsl:template match="/">
      <xsl:for-each select="*/dataset">
         <xsl:call-template name="dataset"/>
      </xsl:for-each>
   </xsl:template>
   
   <!-- parse data set info -->
   <xsl:template name="dataset">
      
      <!-- check for at least one dataTable entity with a download url -->
      <xsl:if test="dataTable/physical/distribution/online/url[@function='download'] != '' or dataTable/physical/distribution/online/url[not(@function)] != ''">
         <xsl:call-template name="code">
            <xsl:with-param name="packageId">
               <xsl:value-of select="../@packageId"/>
            </xsl:with-param>
         </xsl:call-template>
      </xsl:if>
      
   </xsl:template>
   
   <!-- generate function code -->
   <xsl:template name="code">
      
      <!-- get packageId parameter from template parameter -->
      <xsl:param name="packageId"/>
      
      <!-- generate function header -->
      <xsl:text>function [entities,entitydesc] = </xsl:text><xsl:value-of select="translate($packageId,'-.','__')"/><xsl:text>_entities&#xD;</xsl:text>
      <xsl:text>%Returns a list of entity names for EML-described tables in data package </xsl:text><xsl:value-of select="$packageId"/><xsl:text>&#xD;</xsl:text>
      <xsl:text>%&#xD;&#xA;</xsl:text>
      <xsl:text>%syntax: [entities,entitydesc] = </xsl:text><xsl:value-of select="translate($packageId,'-.','__')"/><xsl:text>_entities&#xD;&#xA;</xsl:text>
      <xsl:text>%&#xD;&#xA;</xsl:text>      
      <xsl:text>%input:&#xD;&#xA;</xsl:text>
      <xsl:text>%   none&#xD;&#xA;</xsl:text>
      <xsl:text>%&#xD;&#xA;</xsl:text>
      <xsl:text>%output:&#xD;&#xA;</xsl:text>
      <xsl:text>%   entities = cell array of entity names for compatible data tables ([] if none are identified)&#xD;&#xA;</xsl:text>
      <xsl:text>%   entitydesc = cell array of entity descriptions for compatible data tables ([] if none are identified)&#xD;&#xA;</xsl:text>
      <xsl:text>%&#xD;&#xA;</xsl:text>
      <xsl:text>%auto-generated by EMLdatasetEntities.xsl v0.1 (http://gce-lter.marsci.uga.edu/public/xsl/toolbox/EMLdatasetEntities.xsl)&#xD;&#xA;</xsl:text>
      <xsl:text>%&#xD;&#xA;</xsl:text>
      <xsl:text>%by Wade Sheldon &lt;sheldon@uga.edu&gt;, Georgia Coastal Ecosystems LTER&#xD;&#xA;&#xD;&#xA;</xsl:text>
      
      <!-- open entities array -->
      <xsl:text>%define entities output variable&#xD;&#xA;</xsl:text>      
      <xsl:text>entities = [ ...&#xD;&#xA;</xsl:text>      
      
      <!-- iterate through dataTable elements adding entity names for compatible tables -->
      <xsl:for-each select="dataTable">
         <xsl:if test="physical/distribution/online/url != '' and physical/dataFormat/textFormat/simpleDelimited != ''">
            <xsl:text>   {'</xsl:text>
            <xsl:call-template name="doubleApostrophe">
               <!-- escape apostrophes -->
               <xsl:with-param name="string" select="normalize-space(entityName)"/>
            </xsl:call-template>
            <xsl:text>'}; ...&#xD;&#xA;</xsl:text>
         </xsl:if>
      </xsl:for-each>

      <!-- close entities array -->
      <xsl:text>   ];&#xD;&#xA;&#xD;&#xA;</xsl:text>      
      
      <!-- open entitydesc array -->
      <xsl:text>%define entitydesc output variable&#xD;&#xA;</xsl:text>      
      <xsl:text>entitydesc = [ ...&#xD;&#xA;</xsl:text>      
      
      <!-- iterate through dataTable elements adding entity names for compatible tables -->
      <xsl:for-each select="dataTable">
         <xsl:if test="physical/distribution/online/url != '' and physical/dataFormat/textFormat/simpleDelimited != ''">
            <xsl:text>   {'</xsl:text>
            <xsl:call-template name="doubleApostrophe">
               <!-- escape apostrophes -->
               <xsl:with-param name="string" select="normalize-space(entityDescription)"/>
            </xsl:call-template>
            <xsl:text>'}; ...&#xD;&#xA;</xsl:text>
         </xsl:if>
      </xsl:for-each>
      
      <!-- close entitydesc array -->
      <xsl:text>   ];&#xD;&#xA;</xsl:text>      
      
   </xsl:template>
   
   <!-- template for escaping apostrophes in variable contents to prevent MATLAB syntax errors -->
   <xsl:template name="doubleApostrophe">
      <xsl:param name="string" />
      <xsl:variable name="apostrophe">'</xsl:variable>
      <xsl:choose>
         <xsl:when test="contains($string,$apostrophe)">
            <xsl:value-of select="concat(substring-before($string,$apostrophe), $apostrophe,$apostrophe)" disable-output-escaping="yes" />
            <xsl:call-template name="doubleApostrophe">
               <xsl:with-param name="string" select="substring-after($string,$apostrophe)" />
            </xsl:call-template>
         </xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="$string" disable-output-escaping="yes" />
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   
 </xsl:stylesheet>